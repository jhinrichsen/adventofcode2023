package adventofcode2023

import (
	"bufio"
	"fmt"
	"os"
)

// Cell repräsentiert eine Zelle im zweidimensionalen Feld.
type Cell struct {
	north bool
	east  bool
	south bool
	west  bool
	start bool // Markiert, ob dies der Startpunkt ist
}

// Day10Grid ist ein zweidimensionales Feld von Zellen.
type Day10Grid struct {
	cells  [][]Cell
	width  int
	height int
	startX int
	startY int
}

// Day10NewGrid erstellt ein neues Day10Grid mit der angegebenen Breite und Höhe.
func Day10NewGrid(width, height int) *Day10Grid {
	cells := make([][]Cell, height)
	for i := range cells {
		cells[i] = make([]Cell, width)
	}
	return &Day10Grid{cells: cells, width: width, height: height}
}

// SetExits setzt die Ein- und Ausgänge basierend auf dem gegebenen Buchstaben.
func (g *Day10Grid) SetExits(x, y int, symbol string) {
	switch symbol {
	case "L":
		g.cells[y][x].north = true
		g.cells[y][x].east = true
	case "I":
		g.cells[y][x].north = true
		g.cells[y][x].south = true
	case "J":
		g.cells[y][x].north = true
		g.cells[y][x].west = true
	case "F":
		g.cells[y][x].east = true
		g.cells[y][x].south = true
	case "7":
		g.cells[y][x].west = true
		g.cells[y][x].south = true
	case "-":
		g.cells[y][x].west = true
		g.cells[y][x].east = true
	case "S":
		g.cells[y][x].start = true
		g.startX, g.startY = x, y // Setzt die Startposition
	}
}

// BFS findet die Zelle, die am weitesten vom Startpunkt entfernt ist.
func (g *Day10Grid) FindFarthestCell() (int, int, int) {
	type Point struct {
		x, y, distance int
	}
	queue := []Point{{g.startX, g.startY, 0}}
	visited := make(map[[2]int]bool)
	visited[[2]int{g.startX, g.startY}] = true

	farthestX, farthestY, maxDistance := g.startX, g.startY, 0

	for len(queue) > 0 {
		point := queue[0]
		queue = queue[1:]

		if point.distance > maxDistance {
			maxDistance = point.distance
			farthestX, farthestY = point.x, point.y
		}

		// Überprüfen der möglichen Bewegungen
		directions := []struct {
			dx, dy int
			valid  func(x, y int) bool
		}{
			{0, -1, func(x, y int) bool { return g.cells[y][x].north }}, // nach Norden
			{1, 0, func(x, y int) bool { return g.cells[y][x].east }},   // nach Osten
			{0, 1, func(x, y int) bool { return g.cells[y][x].south }},  // nach Süden
			{-1, 0, func(x, y int) bool { return g.cells[y][x].west }},  // nach Westen
		}

		for _, direction := range directions {
			newX, newY := point.x+direction.dx, point.y+direction.dy
			if newX >= 0 && newX < g.width && newY >= 0 && newY < g.height && !visited[[2]int{newX, newY}] && direction.valid(newX, newY) {
				visited[[2]int{newX, newY}] = true
				queue = append(queue, Point{newX, newY, point.distance + 1})
			}
		}
	}

	return farthestX, farthestY, maxDistance
}

// PrintGrid gibt das Day10Grid in einer lesbaren Form aus.
func (g *Day10Grid) PrintGrid() {
	for y := 0; y < g.height; y++ {
		for x := 0; x < g.width; x++ {
			cell := g.cells[y][x]
			symbol := " "
			if cell.start {
				symbol = "S"
			}
			fmt.Printf("%s ", symbol)
		}
		fmt.Println()
	}
}

// LoadGridFromFile lädt das Day10Grid aus einer Datei im testdata-Verzeichnis.
func LoadGridFromFile(filename string) (*Day10Grid, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	grid := Day10NewGrid(10, 10)
	scanner := bufio.NewScanner(file)
	y := 0
	for scanner.Scan() {
		line := scanner.Text()
		for x, char := range line {
			grid.SetExits(x, y, string(char))
		}
		y++
	}

	return grid, scanner.Err()
}

// Day10ChatGPT returns the farthtest cell and the number of steps.
// The code is completely generated by ChatGPT, including german comments.
func Day10ChatGPT() (uint, error) {
	// Pfad zur Datei anpassen
	grid, err := LoadGridFromFile("testdata/day10_example.txt")
	if err != nil {
		return 0, err
	}

	grid.PrintGrid()

	farthestX, farthestY, maxDistance := grid.FindFarthestCell()
	fmt.Printf("Farthest cell from S is at (%d, %d) with a distance of %d steps.\n", farthestX, farthestY, maxDistance)
	return uint(maxDistance), nil
}
