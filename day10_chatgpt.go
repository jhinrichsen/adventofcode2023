package adventofcode2023

import (
	"bufio"
	"fmt"
	"image"
	"math"
	"os"
)

// Cell repräsentiert eine Zelle im zweidimensionalen Feld.
type Cell struct {
	north bool
	east  bool
	south bool
	west  bool
	start bool // Markiert, ob dies der Startpunkt ist
}

// Day10Grid ist ein zweidimensionales Feld von Zellen.
type Day10Grid struct {
	cells  [][]Cell
	width  int
	height int
	startX int
	startY int
}

// Day10NewGrid erstellt ein neues Day10Grid mit der angegebenen Breite und Höhe.
func Day10NewGrid(width, height int) *Day10Grid {
	cells := make([][]Cell, height)
	for i := range cells {
		cells[i] = make([]Cell, width)
	}
	return &Day10Grid{cells: cells, width: width, height: height}
}

// SetExits setzt die Ein- und Ausgänge basierend auf dem gegebenen Buchstaben.
func (g *Day10Grid) SetExits(x, y int, symbol string) {
	switch symbol {
	case "L":
		g.cells[y][x].north = true
		g.cells[y][x].east = true
	case "I":
		g.cells[y][x].north = true
		g.cells[y][x].south = true
	case "J":
		g.cells[y][x].north = true
		g.cells[y][x].west = true
	case "F":
		g.cells[y][x].east = true
		g.cells[y][x].south = true
	case "7":
		g.cells[y][x].west = true
		g.cells[y][x].south = true
	case "-":
		g.cells[y][x].west = true
		g.cells[y][x].east = true
	case "S":
		g.cells[y][x].start = true
		g.startX, g.startY = x, y // Setzt die Startposition
	}
}

// BFS findet die Zelle, die am weitesten vom Startpunkt entfernt ist.
func (g *Day10Grid) FindFarthestCell() (int, int, int) {
	type Point struct {
		x, y, distance int
	}
	queue := []Point{{g.startX, g.startY, 0}}
	visited := make(map[[2]int]bool)
	visited[[2]int{g.startX, g.startY}] = true

	farthestX, farthestY, maxDistance := g.startX, g.startY, 0

	for len(queue) > 0 {
		point := queue[0]
		queue = queue[1:]

		if point.distance > maxDistance {
			maxDistance = point.distance
			farthestX, farthestY = point.x, point.y
		}

		// Überprüfen der möglichen Bewegungen
		directions := []struct {
			dx, dy int
			valid  func(x, y int) bool
		}{
			{0, -1, func(x, y int) bool { return g.cells[y][x].north }}, // nach Norden
			{1, 0, func(x, y int) bool { return g.cells[y][x].east }},   // nach Osten
			{0, 1, func(x, y int) bool { return g.cells[y][x].south }},  // nach Süden
			{-1, 0, func(x, y int) bool { return g.cells[y][x].west }},  // nach Westen
		}

		for _, direction := range directions {
			newX, newY := point.x+direction.dx, point.y+direction.dy
			if newX >= 0 && newX < g.width && newY >= 0 && newY < g.height && !visited[[2]int{newX, newY}] && direction.valid(newX, newY) {
				visited[[2]int{newX, newY}] = true
				queue = append(queue, Point{newX, newY, point.distance + 1})
			}
		}
	}

	return farthestX, farthestY, maxDistance
}

// PrintGrid gibt das Day10Grid in einer lesbaren Form aus.
func (g *Day10Grid) PrintGrid() {
	for y := 0; y < g.height; y++ {
		for x := 0; x < g.width; x++ {
			cell := g.cells[y][x]
			symbol := " "
			if cell.start {
				symbol = "S"
			}
			fmt.Printf("%s ", symbol)
		}
		fmt.Println()
	}
}

// LoadGridFromFile lädt das Day10Grid aus einer Datei im testdata-Verzeichnis.
func LoadGridFromFile(filename string) (*Day10Grid, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	grid := Day10NewGrid(10, 10)
	scanner := bufio.NewScanner(file)
	y := 0
	for scanner.Scan() {
		line := scanner.Text()
		for x, char := range line {
			grid.SetExits(x, y, string(char))
		}
		y++
	}

	return grid, scanner.Err()
}

// Day10ChatGPT returns the farthtest cell and the number of steps.
// The code is completely generated by ChatGPT, including german comments.
func Day10ChatGPT() (uint, error) {
	// Pfad zur Datei anpassen
	grid, err := LoadGridFromFile("testdata/day10_example.txt")
	if err != nil {
		return 0, err
	}

	grid.PrintGrid()

	farthestX, farthestY, maxDistance := grid.FindFarthestCell()
	fmt.Printf("Farthest cell from S is at (%d, %d) with a distance of %d steps.\n", farthestX, farthestY, maxDistance)
	return uint(maxDistance), nil
}

// IsPointInPolygonStrict determines if a point is strictly inside a polygon
// Points on the edge of the polygon are NOT considered inside.
func IsPointInPolygonStrict(point image.Point, polygon []image.Point) bool {
	n := len(polygon)
	if n < 3 {
		return false // A polygon must have at least 3 points
	}

	inside := false
	for i, j := 0, n-1; i < n; j, i = i, i+1 {
		pi := polygon[i]
		pj := polygon[j]

		// Check if point lies on the edge
		if isPointOnLine(point, pj, pi) {
			return false // Point is on the boundary
		}

		// Ray-casting algorithm
		intersect := ((pi.Y > point.Y) != (pj.Y > point.Y)) &&
			(float64(point.X) < float64(pj.X-pi.X)*(float64(point.Y-pi.Y)/float64(pj.Y-pi.Y))+float64(pi.X))
		if intersect {
			inside = !inside
		}
	}
	return inside
}

// isPointOnLine checks if a point lies exactly on a line segment
func isPointOnLine(point, start, end image.Point) bool {
	// Check if the point is on the line segment using cross product and bounds
	crossProduct := (point.Y-start.Y)*(end.X-start.X) - (point.X-start.X)*(end.Y-start.Y)
	if math.Abs(float64(crossProduct)) > 1e-9 {
		return false // Not collinear
	}

	dotProduct := (point.X-start.X)*(end.X-start.X) + (point.Y-start.Y)*(end.Y-start.Y)
	if dotProduct < 0 {
		return false // Not within segment bounds
	}

	squaredLength := (end.X-start.X)*(end.X-start.X) + (end.Y-start.Y)*(end.Y-start.Y)
	return dotProduct <= squaredLength
}
